# 类

进入类部分，面向对象编程

## 简单类

编程思想和方法的改变

1.类的成员函数可以访问该类的其他成员函数

2.类成员函数可以重载

3.类指针的用法与结构体指针用户相同

4.类的成员可以是任意类型的数据

5.可以为类的成员指定缺省参数

## 类的访问权限

c++只有三种权限，java有四种，有一种默认的 ，如果缺省他是private的

## 析构和构造

构造函数：在对象创建时，执行初始化操作
析构函数：在销毁对象前，执行清理操作

代码案例

```c++
// LeiDemo01.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//
//但是如果有默认参数的，People p 就会导致不明确
#include <iostream>
using namespace std;
class People {

private:
    string name;
    int age;

public:
    People() {
        this->name = "";
        this->age = 0;
    }
    void setName(string name) {
        this->name = name;
    }

    void setAge(int age) {
        this->age = age;
    }

    string getName() {
        return name;
    }

    int getAge() {
        return age;
    }

    void printInfo() {
        cout << "name :" << name << "age:" << age;
    }
};

int main()
{
    People* p = new People();
    p->printInfo();

    People p1;
    p1.printInfo();
    std::cout << "Hello World!\n";
}

```

析构函数：
- 必须是public ，可以手动调用


## 拷贝

使用一个对象创建一个新对象，不是使用构造函数，而是拷贝函数，如果用户没提供新的拷贝函数，那么就会使用一个默认的，将老的成员变量放入新的成员变量中

代码演示
```c++
People p ;
People p1(p);
People p2 = p;
```

自定义拷贝函数

```c++
Poeple(const People& people)
```

值传递的时候
```java
void show(People p){
    
}

调用它的时候，会执行调用拷贝函数
```

## 初始化列表

```c++
class People{
    ……
    People():name("wang"),age(1) {
        this->name = "";
        this->age = 0;
    }
}

```

## 构造函数的细节

- 如果没写构造或者析构，就会自己创建一个默认的
- 如果通过了构造和析构，那么就不会通过空的
- 不要使用`People p()`会认为在声明函数
- 构造函数后面加()或者参数，是创建匿名类
- 冷门创建方式
```c++
People p = People();
```
- new/delete:new会执行构造函数  delete会执行析构函数
## 线程

C++11之前，c++没有对线程有语言级别的支持，各种系统实现方法不一致

C++11增加了线程以及线程相关的类

## 创建线程

1.头文件: #include<thread>

2.线程类：std::thread

### 构造函数

1.thread()noexcept; 默认构造函数，构造一个线程对象，不执行任何任务,一般不使用。

2.timplate<class Function,class…… args> explicit thread(Function &&fx，Args &&…… args);
百分之99用这个，它会创建对象，在线程中执行函数fx,args是传入的参数

```c++
#include <iostream>
#include <thread>
#include <windows.h>
using namespace std;
void func() {
    for (int i = 0; i <= 10; i++) {
        cout << "这是一句话！" << endl;
        Sleep(1000);
    }
}

int main()
{
    thread *t1 = new thread(func);
    for(int i = 0;i <= 10; i++){
        std::cout << "Hello World!\n";
        Sleep(1000);
    }
    t1->join();
}

```

3.thread（thread&& other）noexcept;移动构造函数，将线程